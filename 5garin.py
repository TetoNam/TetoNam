import cv2
import numpy as np
from flask import Flask, Response
from ultralytics import YOLO
import time
import afb
import serial
import threading
import signal
import sys
import queue
import os
import socket
import glob

# --- ÏµúÏ†ÅÌôî ÏÑ§Ï†ï ---
SERIAL_PORT = '/dev/ttyUSB0'
BAUD_RATE = 9600
YOLO_PROCESS_INTERVAL = 8
MAX_STREAM_FPS = 30

# --- ÏãúÎ¶¨Ïñº Ìè¨Ìä∏ Ï¥àÍ∏∞Ìôî ---
def init_serial():
    try:
        ser = serial.Serial(SERIAL_PORT, BAUD_RATE, timeout=0.05)
        time.sleep(1.5)
        print(f"‚úì ÏßÄÏ†ïÎêú ÏãúÎ¶¨Ïñº Ìè¨Ìä∏ ({SERIAL_PORT}) Ïó∞Í≤∞ ÏÑ±Í≥µ")
        ser.flushInput()
        return ser
    except serial.SerialException:
        print(f"‚úó ÏßÄÏ†ïÎêú Ìè¨Ìä∏({SERIAL_PORT}) Ïó∞Í≤∞ Ïã§Ìå®. Îã§Î•∏ Ìè¨Ìä∏Î•º Í≤ÄÏÉâÌï©ÎãàÎã§...")
        possible_ports = glob.glob('/dev/ttyACM*') + glob.glob('/dev/ttyUSB*')
        for port in possible_ports:
            try:
                ser = serial.Serial(port, BAUD_RATE, timeout=0.05)
                time.sleep(1.5)
                print(f"‚úì ÏûêÎèô Í≤ÄÏÉâÎêú ÏãúÎ¶¨Ïñº Ìè¨Ìä∏ ({port}) Ïó∞Í≤∞ ÏÑ±Í≥µ")
                ser.flushInput()
                return ser
            except Exception:
                continue
    print("‚úó Í≤ΩÍ≥†: Ïñ¥Îñ§ ÏãúÎ¶¨Ïñº Ìè¨Ìä∏ÎèÑ Ïó∞Í≤∞Ìï† Ïàò ÏóÜÏäµÎãàÎã§.")
    return None

ser = init_serial()

# --- Î™®Îç∏ Î∞è Ïπ¥Î©îÎùº Ï¥àÍ∏∞Ìôî (Ïù¥Ï†ÑÍ≥º ÎèôÏùº) ---
print("ü§ñ YOLO Î™®Îç∏ Î°úÎî© Ï§ë...")
model = YOLO("/home/pi/braille/last.pt")
print("‚úì YOLO Î™®Îç∏ Î°úÎî© ÏôÑÎ£å")
try:
    afb.camera.init(640, 480, 30)
    print("‚úì Ïπ¥Î©îÎùº Ï¥àÍ∏∞Ìôî ÏÑ±Í≥µ")
except Exception as e:
    print(f"‚úó ÏπòÎ™ÖÏ†Å Ïò§Î•ò: Ïπ¥Î©îÎùºÎ•º Ïº§ Ïàò ÏóÜÏäµÎãàÎã§. Ïò§Î•ò: {e}")
    sys.exit(1)

app = Flask(__name__)

# --- Ï†ÑÏó≠ Î≥ÄÏàò Î∞è ÌÅ¥ÎûòÏä§ (Ïù¥Ï†ÑÍ≥º ÎèôÏùº) ---
frame_count = 0
current_frame = None
frame_lock = threading.Lock()
yolo_results = {'last_update': 0}
yolo_lock = threading.Lock()

class HighPerformanceSerial:
    def __init__(self, serial_connection):
        self.ser = serial_connection
        self.lock = threading.Lock()
        self.signal_queue = queue.Queue(maxsize=1)
        self.running = True
    def send_signal(self, signal):
        if not self.ser: return
        try:
            while not self.signal_queue.empty():
                self.signal_queue.get_nowait()
            self.signal_queue.put_nowait(signal)
        except queue.Full: pass
    def communication_worker(self):
        while self.running:
            try:
                if not self.ser:
                    time.sleep(0.1)
                    continue
                signal_data = self.signal_queue.get(timeout=0.2)
                with self.lock:
                    message = signal_data + '\n'
                    self.ser.write(message.encode('utf-8'))
                    self.ser.flush()
            except queue.Empty: continue
            except Exception as e:
                print(f"ÌÜµÏã† Ïä§Î†àÎìú Ïò§Î•ò: {e}")
                time.sleep(0.1)

hp_serial = HighPerformanceSerial(ser)

class YOLOProcessor:
    def __init__(self, model):
        self.model = model
        self.running = True
        self.camera_ref_point = (320, 460)
        self.last_sent_signal = None 
    def process_yolo_worker(self):
        global frame_count, yolo_results
        while self.running:
            try:
                if frame_count > 0 and frame_count % YOLO_PROCESS_INTERVAL == 0:
                    with frame_lock:
                        if current_frame is None: continue
                        frame_to_process = current_frame.copy()
                    
                    frame_rgb = cv2.cvtColor(frame_to_process, cv2.COLOR_BGR2RGB)
                    results = self.model.predict(frame_rgb, imgsz=640, conf=0.3, verbose=False)[0]
                    new_results = self.analyze_results(results)
                    
                    with yolo_lock:
                        yolo_results.update(new_results)
                        yolo_results['last_update'] = time.time()
                    
                    current_signal = new_results.get('current_signal')
                    if current_signal and current_signal != self.last_sent_signal:
                        print(f"‚úÖ ÏÉÅÌÉú Î≥ÄÍ≤Ω Í∞êÏßÄ: '{self.last_sent_signal}' -> '{current_signal}'. Ïã†Ìò∏ Ï†ÑÏÜ°!")
                        hp_serial.send_signal(current_signal)
                        self.last_sent_signal = current_signal
                
                time.sleep(0.01)
            except Exception as e:
                print(f"YOLO Ï≤òÎ¶¨ Ïò§Î•ò: {e}")
                time.sleep(0.1)
    
    def analyze_results(self, results):
        stop_centroid, lowest_go_point = None, None
        all_go_bottom_centers = []
        current_signal = 'S'
        guidance_text = ''
        if results.masks:
            class_names = self.model.names
            go_masks, stop_masks = [], []
            for i, box in enumerate(results.boxes):
                if len(results.masks) > i:
                    cls_id = int(box.cls[0])
                    class_name = class_names[cls_id]
                    if class_name == 'go': go_masks.append(results.masks.xy[i])
                    elif class_name == 'stop': stop_masks.append(results.masks.xy[i])
            
            if stop_masks:
                mask_points = stop_masks[0].astype(int)
                M = cv2.moments(mask_points)
                if M["m00"] != 0:
                    stop_centroid = (int(M["m10"] / M["m00"]), int(M["m01"] / M["m00"]))
            
            max_y = -1
            for go_contour in go_masks:
                points_sorted = sorted(go_contour, key=lambda p: p[1], reverse=True)
                if len(points_sorted) >= 2:
                    p1, p2 = points_sorted[0], points_sorted[1]
                    target_point = (int((p1[0] + p2[0]) / 2), int((p1[1] + p2[1]) / 2))
                    all_go_bottom_centers.append(target_point)
                    if target_point[1] > max_y:
                        max_y = target_point[1]
                        lowest_go_point = target_point
            
            if stop_centroid and stop_centroid[1] > 240 and len(all_go_bottom_centers) >= 1:
                num_go = len(all_go_bottom_centers)
                if num_go >= 3:
                    current_signal, guidance_text = ("C", "ÍµêÏ∞®Î°ú")
                else:
                    x_diff = sum(gp[0] - stop_centroid[0] for gp in all_go_bottom_centers)
                    current_signal, guidance_text = ("B", "Ï¢åÌöåÏ†Ñ") if x_diff < 0 else ("W", "Ïö∞ÌöåÏ†Ñ")
            elif lowest_go_point:
                dead_zone = 25 
                if lowest_go_point[0] < self.camera_ref_point[0] - dead_zone:
                    current_signal = 'L'
                elif lowest_go_point[0] > self.camera_ref_point[0] + dead_zone:
                    current_signal = 'R'
                else:
                    current_signal = 'S'
        return {'current_signal': current_signal, 'guidance_text': guidance_text}

yolo_processor = YOLOProcessor(model)

# üí° [Ï∂îÍ∞Ä] ÏïÑÎëêÏù¥ÎÖ∏Î°úÎ∂ÄÌÑ∞ Î©îÏãúÏßÄÎ•º ÏàòÏã†ÌïòÎäî ÏõåÏª§ Ìï®Ïàò
def serial_reader_worker(ser_connection):
    """ÏïÑÎëêÏù¥ÎÖ∏Î°úÎ∂ÄÌÑ∞ Îì§Ïñ¥Ïò§Îäî Î©îÏãúÏßÄÎ•º Í≥ÑÏÜç ÏùΩÏñ¥ÏÑú ÌÑ∞ÎØ∏ÎÑêÏóê Ï∂úÎ†•Ìï©ÎãàÎã§."""
    while True:
        try:
            if ser_connection and ser_connection.in_waiting > 0:
                # Î©îÏãúÏßÄÎ•º Ï§Ñ Îã®ÏúÑÎ°ú ÏùΩÍ≥†, utf-8Î°ú ÎîîÏΩîÎî©ÌïòÎ©∞, ÏñëÏ™Ω Í≥µÎ∞±ÏùÑ Ï†úÍ±∞Ìï©ÎãàÎã§.
                message = ser_connection.readline().decode('utf-8').strip()
                if message: # Îπà Î©îÏãúÏßÄÍ∞Ä ÏïÑÎãê Í≤ΩÏö∞ÏóêÎßå Ï∂úÎ†•
                    if message == "DFP_OK":
                        print("‚úÖ [ÏïÑÎëêÏù¥ÎÖ∏ ÏùëÎãµ]: DFPlayer Ï¥àÍ∏∞Ìôî ÏÑ±Í≥µ!")
                    elif message == "DFP_FAIL":
                        print("‚ùå [ÏïÑÎëêÏù¥ÎÖ∏ ÏùëÎãµ]: DFPlayer Ï¥àÍ∏∞Ìôî Ïã§Ìå®! Î∞∞ÏÑ†Í≥º SDÏπ¥ÎìúÎ•º ÌôïÏù∏ÌïòÏÑ∏Ïöî.")
                    else:
                        print(f"üí¨ [ÏïÑÎëêÏù¥ÎÖ∏ Î©îÏãúÏßÄ]: {message}")
        except Exception as e:
            print(f"ÏãúÎ¶¨Ïñº ÏùΩÍ∏∞ Ïä§Î†àÎìú Ïò§Î•ò: {e}")
            break # Ïò§Î•ò Î∞úÏÉù Ïãú Ïä§Î†àÎìú Ï¢ÖÎ£å
        time.sleep(0.1)


# --- Ïõπ ÏÑúÎ≤Ñ Î∞è Í∏∞ÌÉÄ Ìï®Ïàò (Ïù¥Ï†ÑÍ≥º ÎèôÏùº) ---
def draw_annotations(frame):
    with yolo_lock: results = yolo_results.copy()
    signal_text = f"Signal: {yolo_processor.last_sent_signal or 'N/A'}"
    cv2.putText(frame, signal_text, (20, 50), cv2.FONT_HERSHEY_SIMPLEX, 1.2, (0, 255, 0), 3)
    if time.time() - results.get('last_update', 0) > 1.5: return frame
    if results.get('stop_centroid'): cv2.circle(frame, results['stop_centroid'], 7, (0, 255, 255), -1)
    for go_point in results.get('all_go_bottom_centers', []): cv2.drawMarker(frame, go_point, (255, 0, 255), cv2.MARKER_TILTED_CROSS, 15, 2)
    if results.get('lowest_go_point'): cv2.line(frame, yolo_processor.camera_ref_point, results['lowest_go_point'], (255, 255, 0), 2)
    if results.get('guidance_text'): cv2.putText(frame, results['guidance_text'], (50, 100), cv2.FONT_HERSHEY_TRIPLEX, 1.2, (0, 0, 255), 2)
    return frame
def camera_capture_worker():
    global frame_count, current_frame
    while yolo_processor.running:
        try:
            frame = afb.camera.get_image()
            if frame.shape[2] == 4: frame = cv2.cvtColor(frame, cv2.COLOR_BGRA2BGR)
            with frame_lock:
                current_frame = frame
                frame_count += 1
            time.sleep(1/MAX_STREAM_FPS)
        except Exception as e:
            print(f"Ïπ¥Î©îÎùº Ï∫°Ï≤ò Ï§ë Ïò§Î•ò Î∞úÏÉù: {e}")
            time.sleep(0.5)
def generate():
    while True:
        try:
            with frame_lock:
                if current_frame is None: 
                    time.sleep(0.01)
                    continue
                frame_to_stream = current_frame.copy()
            annotated_frame = draw_annotations(frame_to_stream)
            _, buffer = cv2.imencode('.jpg', annotated_frame, [int(cv2.IMWRITE_JPEG_QUALITY), 90])
            yield (b'--frame\r\n' b'Content-Type: image/jpeg\r\n\r\n' + buffer.tobytes() + b'\r\n')
            time.sleep(1/MAX_STREAM_FPS)
        except Exception as e:
            print(f"Ïä§Ìä∏Î¶¨Î∞ç Ïò§Î•ò: {e}")
            break
@app.route('/video')
def video(): return Response(generate(), mimetype='multipart/x-mixed-replace; boundary=frame')
@app.route('/')
def index(): return '<h1>üöÄ Ultra-Fast Haptic Guidance</h1><img src="/video" width="640" height="480">'
def start_all_threads():
    print("üöÄ Í≥†ÏÑ±Îä• Ïä§Î†àÎìú ÏãúÏûë Ï§ë...")
    camera_thread = threading.Thread(target=camera_capture_worker, daemon=True)
    camera_thread.start()
    print("‚úì Ïπ¥Î©îÎùº Ïä§Î†àÎìú ÏãúÏûë")
    yolo_thread = threading.Thread(target=yolo_processor.process_yolo_worker, daemon=True)
    yolo_thread.start()
    print("‚úì YOLO Ï≤òÎ¶¨ Ïä§Î†àÎìú ÏãúÏûë")
    if ser:
        serial_thread = threading.Thread(target=hp_serial.communication_worker, daemon=True)
        serial_thread.start()
        print("‚úì ÏãúÎ¶¨Ïñº ÌÜµÏã† Ïä§Î†àÎìú ÏãúÏûë")
def cleanup_and_exit(signum, frame):
    print(f"\nüõë ÏãúÏä§ÌÖú Ï¢ÖÎ£å Ï§ë...")
    yolo_processor.running = False
    hp_serial.running = False
    if ser:
        try:
            ser.write(b'S\n')
            ser.close()
            print("‚úì ÏãúÎ¶¨Ïñº Ïó∞Í≤∞ Ï¢ÖÎ£å")
        except: pass
    print("üëã ÏãúÏä§ÌÖú Ï¢ÖÎ£å ÏôÑÎ£å")
    sys.exit(0)
def get_ip_address():
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
        s.close()
        return ip
    except Exception: return "127.0.0.1"
signal.signal(signal.SIGINT, cleanup_and_exit)
signal.signal(signal.SIGTERM, cleanup_and_exit)

if __name__ == '__main__':
    try:
        print("üöÄ Ultra-Fast ÌñÖÌã± Í∞ÄÏù¥Îìú ÏãúÏä§ÌÖú ÏãúÏûë (ÏÉÅÌÉú Í¥ÄÎ¶¨ Ï†ÅÏö©)!")
        start_all_threads()
        
        # üí° [Ï∂îÍ∞Ä] ÏïÑÎëêÏù¥ÎÖ∏ Î©îÏãúÏßÄ ÏàòÏã† Ïä§Î†àÎìú ÏãúÏûë
        if ser:
            reader_thread = threading.Thread(target=serial_reader_worker, args=(ser,), daemon=True)
            reader_thread.start()
            print("‚úì Arduino Î©îÏãúÏßÄ ÏàòÏã† Ïä§Î†àÎìú ÏãúÏûëÎê®.")

        time.sleep(2)
        
        ip_address = get_ip_address()
        print("="*50)
        print("üåê Ïõπ ÏÑúÎ≤Ñ Ï†ëÏÜç Ï£ºÏÜå (ÎîîÎ≤ÑÍπÖÏö©):")
        print(f"  http://{ip_address}:5000")
        print("="*50)
        
        app.run(host='0.0.0.0', port=5000, debug=False, threaded=True, use_reloader=False)

    except Exception as e:
        print(f"‚ùå ÏãúÏä§ÌÖú ÏãúÏûë Ïò§Î•ò: {e}")
        cleanup_and_exit(0, None)